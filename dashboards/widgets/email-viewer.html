<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MBOX Viewer â€” Gmailâ€‘style</title>
  <style>
    :root{
      --bg:#0b0e14; --card:#11151f; --muted:#2a3140; --ink:#e6edf3; --ink-dim:#b7c0cc; --accent:#4aa3ff; --accent-2:#7c4dff; --chip:#1b2230; --danger:#ff4769;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    .app{display:grid;grid-template-columns:260px 1fr;grid-template-rows:56px 1fr;grid-template-areas:"topbar topbar" "sidebar content";height:100%}
    .topbar{grid-area:topbar;display:flex;gap:10px;align-items:center;padding:10px 14px;border-bottom:1px solid var(--muted);background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0));backdrop-filter:saturate(120%) blur(6px);position:sticky;top:0;z-index:5}
    .brand{font-weight:700;letter-spacing:.2px}
    .brand b{color:var(--accent)}
    .btn{border:1px solid var(--muted);background:#0e131c;color:var(--ink);padding:8px 10px;border-radius:10px;cursor:pointer}
    .btn:hover{border-color:#3a4458}
    .file{display:none}
    .pill{padding:6px 10px;border:1px solid var(--muted);border-radius:999px;background:#0e131c}
    .search{flex:1;display:flex;align-items:center;gap:8px;border:1px solid var(--muted);background:#0e131c;border-radius:12px;padding:6px 10px}
    .search input{flex:1;background:transparent;border:0;outline:0;color:var(--ink)}
    .sidebar{grid-area:sidebar;border-right:1px solid var(--muted);overflow:auto;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0));}
    .section{margin:8px 0 16px}
    .section h4{margin:10px 10px;color:var(--ink-dim);font-weight:600;font-size:12px;text-transform:uppercase;letter-spacing:.12em}
    .nav{display:flex;flex-direction:column;gap:4px}
    .nav button{all:unset;display:flex;gap:10px;align-items:center;padding:8px 10px;border-radius:10px;color:var(--ink-dim);cursor:pointer}
    .nav button.active,.nav button:hover{background:#121826;color:var(--ink)}
    .badge{margin-left:auto;background:var(--chip);border:1px solid var(--muted);color:var(--ink-dim);padding:0 8px;border-radius:999px;font-size:12px}
    .labels{display:flex;flex-wrap:wrap;gap:6px;padding:6px 10px}
    .chip{background:var(--chip);border:1px solid var(--muted);padding:6px 10px;border-radius:999px;color:var(--ink-dim);cursor:pointer}
    .chip.active{background:#172036;color:var(--ink);border-color:#3a4458}
    .drop{border:2px dashed #2f394b;border-radius:12px;padding:12px;margin:6px 10px;color:var(--ink-dim);text-align:center}

    .content{grid-area:content;display:grid;grid-template-columns:420px 1fr;min-height:0}
    .list{border-right:1px solid var(--muted);overflow:auto;background:var(--card)}
    .row{display:grid;grid-template-columns: 1fr 120px 140px;gap:10px;padding:12px 14px;border-bottom:1px solid #131a27;cursor:pointer}
    .row:hover{background:#0f1420}
    .row.active{background:#141b2a}
    .subj{font-weight:600;color:var(--ink)}
    .from{color:var(--ink-dim)}
    .labels-mini{display:flex;gap:6px;flex-wrap:wrap}
    .label-pill{font-size:11px;background:#182034;border:1px solid #2a3140;color:#a9b5c5;border-radius:999px;padding:2px 6px}
    .date{text-align:right;color:#9fb1c7;font-variant-numeric:tabular-nums}

    .viewer{overflow:auto;position:relative}
    .viewer .head{padding:16px;border-bottom:1px solid var(--muted);background:var(--card)}
    .viewer h2{margin:0 0 8px;font-size:20px}
    .kv{display:grid;grid-template-columns:110px 1fr;gap:8px;color:var(--ink-dim);font-size:13px}
    .kv div b{color:var(--ink);font-weight:600}
    .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .body{padding:20px}
    .body .htmlbox{border:1px solid var(--muted);border-radius:12px;overflow:hidden;background:#0e131c}
    .body iframe{width:100%;height:60vh;border:0;background:white}
    .body pre{white-space:pre-wrap;word-wrap:break-word;background:#0e131c;border:1px solid var(--muted);padding:14px;border-radius:12px}
    .attachments{padding:0 20px 20px}
    .att{display:flex;justify-content:space-between;align-items:center;border:1px solid var(--muted);border-radius:10px;padding:8px 12px;margin-top:8px;background:#0f1420}
    .att .meta{font-size:13px;color:var(--ink-dim)}
    .hidden{display:none}
    .small{font-size:12px;color:var(--ink-dim)}
    .progress{height:6px;background:#12192a;border-radius:999px;overflow:hidden}
    .progress>div{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:0%}
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">ðŸ“¥ <b>MBOX</b> Viewer</div>
      <label class="btn" title="Open .mbox file">
        <input id="file" class="file" type="file" accept=".mbox,.mbx,text/plain" />
        Open .mbox
      </label>
      <div id="dropzone" class="pill">Drag & drop .mbox here</div>
      <div class="search">
        ðŸ”Ž <input id="q" placeholder="Search (from, subject, body) â€” press Enter" />
      </div>
      <div class="pill small" id="status">No file loaded</div>
    </div>

    <aside class="sidebar">
      <div class="section">
        <h4>Mailboxes</h4>
        <div class="nav" id="navBoxes"></div>
      </div>
      <div class="section">
        <h4>Labels</h4>
        <div class="labels" id="labelChips"></div>
        <div class="drop small">Gmail exports often include <code>Xâ€‘Gmailâ€‘Labels</code> â€” we'll use those here.</div>
      </div>
      <div class="section">
        <h4>Load Progress</h4>
        <div class="progress" title="Parsing progress"><div id="bar"></div></div>
        <div class="small" id="meta"></div>
      </div>
    </aside>

    <section class="content">
      <div class="list" id="list"></div>
      <div class="viewer" id="viewer">
        <div class="head">
          <h2 id="vSubject">Open an email</h2>
          <div class="kv small">
            <div>From</div><div id="vFrom"><b>â€”</b></div>
            <div>To</div><div id="vTo">â€”</div>
            <div>Date</div><div id="vDate">â€”</div>
            <div>Messageâ€‘ID</div><div id="vMsgId">â€”</div>
          </div>
          <div class="chips" id="vLabels"></div>
        </div>
        <div class="body" id="vBody">
          <div class="htmlbox hidden" id="htmlBox"><iframe id="htmlFrame"></iframe></div>
          <pre id="textBox" class="hidden"></pre>
        </div>
        <div class="attachments" id="vAtts"></div>
      </div>
    </section>
  </div>

<script>
// --- Utilities --------------------------------------------------------------
const fmtDate = d => d ? new Date(d).toLocaleString() : "";
const esc = s => (s||"").replace(/[&<>]/g,m=>({"&":"&amp;","<":"&lt;",
  ">":"&gt;"}[m]));
const qpDecode = (str) => {
  // Basic quoted-printable decoder; handles soft line breaks and =XX bytes
  return str
    .replace(/=\r?\n/g, "")
    .replace(/=([0-9A-Fa-f]{2})/g, (_,h) => String.fromCharCode(parseInt(h,16)));
};
const b64DecodeUtf8 = (b64) => {
  try {return decodeURIComponent(escape(atob(b64.replace(/\s+/g, ""))));}
  catch(e){try{return atob(b64.replace(/\s+/g, ""));}catch(_){return b64;}}
};
const parseAddrs = (v) => (v||"")
  .split(/,\s*(?![^<]*>)/).map(s=>s.trim()).filter(Boolean).join(", ");

function parseHeaders(raw){
  // Unfold headers (continuation lines)
  const lines = raw.split(/\r?\n/);
  const out = []; let cur = "";
  for(const ln of lines){
    if(/^\s/.test(ln)) cur += " " + ln.trim();
    else { if(cur) out.push(cur); cur = ln.trim(); }
  }
  if(cur) out.push(cur);
  const headers = {};
  for(const l of out){
    const i = l.indexOf(":"); if(i<0) continue;
    const k = l.slice(0,i).toLowerCase();
    const v = l.slice(i+1).trim();
    (headers[k] ||= []).push(v);
  }
  const get = (k) => (headers[k]?.[0]) || "";
  return {headers, get};
}

function splitMbox(text, onChunk) {
  // Robust line-based splitter:
  // every line that *starts* with "From " begins a new message.
  const lines = text.split(/\r?\n/);
  const parts = [];
  let current = [];
  let count = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (line.startsWith("From ") && current.length) {
      // end of previous message, start a new one
      const chunk = current.join("\n");
      if (chunk.trim()) {
        parts.push(chunk);
        count++;
        if (onChunk) onChunk(count);
      }
      current = [];
      // we *do not* keep the "From " line itself, mbox-style
      continue;
    }

    // collect lines for the current message
    current.push(line);
  }

  // last message
  const tail = current.join("\n");
  if (tail.trim()) {
    parts.push(tail);
    count++;
    if (onChunk) onChunk(count);
  }

  return parts;
}
function stripBase64Blocks(text) {
  const lines = text.split(/\r?\n/);
  const out = [];

  let inBlock = false;
  let blockCount = 0;

  const isB64Line = (line) => {
    const t = line.trim();
    // typical base64 line: long, only Aâ€“Z aâ€“z 0â€“9 + / =
    if (t.length < 40 || t.length > 100) return false;
    return /^[A-Za-z0-9+/]+={0,2}$/.test(t);
  };

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (isB64Line(line)) {
      inBlock = true;
      blockCount++;
      continue;
    }

    if (inBlock) {
      // We just ended a run of base64-like lines
      if (blockCount > 5) {
        // Definitely an attachment blob â€” collapse it
        out.push("[attachment data omitted]");
      } else {
        // Probably not a real blob; put original lines back
        const start = i - blockCount;
        for (let j = start; j < i; j++) out.push(lines[j]);
      }
      inBlock = false;
      blockCount = 0;
    }

    out.push(line);
  }

  // Handle base64 block that runs to EOF
  if (inBlock) {
    if (blockCount > 5) {
      out.push("[attachment data omitted]");
    } else {
      const start = lines.length - blockCount;
      for (let j = start; j < lines.length; j++) out.push(lines[j]);
    }
  }

  return out.join("\n");
}


function parseEmail(raw){
  // Split headers/body
  const sep = /\r?\n\r?\n/;
  const m = raw.split(sep);
  const rawHeaders = m.shift()||"";
  const body = m.join("\n\n");
  const {headers,get} = parseHeaders(rawHeaders);
  const h = (k)=>get(k.toLowerCase());
  const subj = h("subject");
  const from = h("from");
  const to = h("to");
  const date = h("date");
  const msgId = h("message-id");
  const labels = (h("x-gmail-labels")||"")
    .split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/)
    .map(s=>s.trim().replace(/^\"|\"$/g,""))
    .filter(Boolean);
  let content = { kind:"text", value: body };
  let attachments = [];

  // Minimal MIME parsing
  const ctype = (h("content-type")||"text/plain").toLowerCase();
  const cte = (h("content-transfer-encoding")||"").toLowerCase();

  function decodeBody(ct, enc, data){
    if(enc.includes("base64")) data = b64DecodeUtf8(data);
    else if(enc.includes("quoted-printable")) data = qpDecode(data);
    return { ct, data };
  }

  function parseMultipart(boundary, data){
    const bd = "--"+boundary;
    const end = bd+"--";
    const parts = data.split(bd).slice(1); // drop preamble
    const out = [];
    for(let p of parts){
      if(p.trim().startsWith("--")) break; // closing boundary
      p = p.replace(/^\r?\n/,"");
      const [ph, ...rest] = p.split(/\r?\n\r?\n/);
      const pHeaders = parseHeaders(ph);
      const pdata = rest.join("\n\n");
      const ct = (pHeaders.get("content-type")||"text/plain").toLowerCase();
      const enc = (pHeaders.get("content-transfer-encoding")||"").toLowerCase();
      const disp = (pHeaders.get("content-disposition")||"").toLowerCase();
      const nameMatch = /name=\"?([^\";]+)\"?/i.exec(ct) || /filename=\"?([^\";]+)\"?/i.exec(disp);
      const filename = nameMatch ? nameMatch[1] : null;
      out.push({headers:pHeaders, ct, enc, disp, filename, data:pdata});
    }
    return out;
  }

  if(ctype.startsWith("multipart/")){
    const bMatch = /boundary=\"?([^\";]+)\"?/.exec(ctype);
    const boundary = bMatch ? bMatch[1] : null;
    if(boundary){
      const parts = parseMultipart(boundary, body);
      // Prefer text/html, then text/plain
      const htmlPart = parts.find(p=>p.ct.startsWith("text/html"));
      const textPart = parts.find(p=>p.ct.startsWith("text/plain"));
      if(htmlPart){ const d = decodeBody(htmlPart.ct, htmlPart.enc, htmlPart.data); content={kind:"html", value:d.data}; }
      else if(textPart){ const d = decodeBody(textPart.ct, textPart.enc, textPart.data); content={kind:"text", value:d.data}; }
      attachments = parts.filter(p=>/attachment/.test(p.disp)||p.filename).map(p=>{
        const d = decodeBody(p.ct, p.enc, p.data);
        return { filename: p.filename||"attachment", mime: p.ct, raw: d.data };
      });
    } else {
      content = {kind:"text", value: decodeBody(ctype, cte, body).data};
    }
  } else {
    const d = decodeBody(ctype, cte, body);
    content = { kind: ctype.includes("html")?"html":"text", value: d.data };
  }
    // After weâ€™ve picked the main content, clean out any huge base64 blobs
  if (content.kind === "text") {
    content.value = stripBase64Blocks(content.value);
  }

  return {subject: subj||"(no subject)", from, to, date, messageId: msgId, labels, content, attachments, headers};
}

// --- App state --------------------------------------------------------------
const state = {
  emails: [],
  filtered: [],
  active: -1,
  mailbox: 'All Mail',
  labels: new Map(),
  query: '',
  labelFilter: null,
};

function renderNav(){
  const el = document.getElementById('navBoxes');
  el.innerHTML = '';
  const boxes = [
    {name:'Inbox', filter:(e)=>e.labels.includes('Inbox')},
    {name:'Starred', filter:(e)=>e.labels.includes('Starred')},
    {name:'Sent', filter:(e)=>/\bSent\b/.test(e.labels.join(','))},
    {name:'Drafts', filter:(e)=>e.labels.includes('Drafts')},
    {name:'Spam', filter:(e)=>e.labels.includes('Spam')},
    {name:'Trash', filter:(e)=>e.labels.includes('Trash')},
    {name:'All Mail', filter:(_)=>true},
  ];
  boxes.forEach(b=>{
    const btn = document.createElement('button');
    btn.textContent = b.name;
    if(state.mailbox===b.name) btn.classList.add('active');
    const count = state.emails.filter(b.filter).length;
    const badge = document.createElement('span');
    badge.className='badge';
    badge.textContent = count;
    btn.appendChild(badge);
    btn.onclick = ()=>{ state.mailbox=b.name; filterEmails(); };
    el.appendChild(btn);
  });
}

function renderLabelChips(){
  const el = document.getElementById('labelChips');
  el.innerHTML='';
  const labels = Array.from(state.labels.keys()).filter(l=>!['Inbox','Starred','Sent','Drafts','Spam','Trash'].includes(l)).sort();
  const all = document.createElement('div');
  all.className = 'chip' + (state.labelFilter? '': ' active');
  all.textContent = 'All labels';
  all.onclick = ()=>{ state.labelFilter=null; filterEmails(); };
  el.appendChild(all);
  labels.forEach(l=>{
    const c = document.createElement('div');
    c.className = 'chip' + (state.labelFilter===l? ' active': '');
    c.textContent = l + ' (' + state.labels.get(l) + ')';
    c.onclick = ()=>{ state.labelFilter = (state.labelFilter===l? null : l); filterEmails(); };
    el.appendChild(c);
  });
}

function filterEmails(){
  const lowerQ = (state.query||'').toLowerCase();
  const boxFilter = {
    'Inbox': (e)=>e.labels.includes('Inbox'),
    'Starred': (e)=>e.labels.includes('Starred'),
    'Sent': (e)=>/\bSent\b/.test(e.labels.join(',')),
    'Drafts': (e)=>e.labels.includes('Drafts'),
    'Spam': (e)=>e.labels.includes('Spam'),
    'Trash': (e)=>e.labels.includes('Trash'),
    'All Mail': (_)=>true,
  }[state.mailbox] || ((_)=>true);

  state.filtered = state.emails.filter(e=>{
    if(!boxFilter(e)) return false;
    if(state.labelFilter && !e.labels.includes(state.labelFilter)) return false;
    if(!lowerQ) return true;
    const hay = (e.subject+"\n"+e.from+"\n"+e.content.value).toLowerCase();
    return hay.includes(lowerQ);
  }).sort((a,b)=> (new Date(b.date)) - (new Date(a.date)));

  renderList();
  renderNav();
}

function renderList(){
  const list = document.getElementById('list');
  list.innerHTML='';
  state.filtered.forEach((e,idx)=>{
    const row = document.createElement('div');
    row.className = 'row' + (idx===state.active? ' active':'');
    const left = document.createElement('div');
    const subj = document.createElement('div'); subj.className='subj'; subj.textContent=e.subject||'(no subject)';
    const from = document.createElement('div'); from.className='from small'; from.textContent=(e.from||'').replace(/\s*</,' <');
    const labs = document.createElement('div'); labs.className='labels-mini';
    e.labels.slice(0,4).forEach(l=>{ const p=document.createElement('span'); p.className='label-pill'; p.textContent=l; labs.appendChild(p); });
    left.appendChild(subj); left.appendChild(from); left.appendChild(labs);

    const mid = document.createElement('div'); mid.className='small'; mid.innerHTML = esc((e.to||'').split(',')[0]||'');

    const right = document.createElement('div'); right.className='date'; right.textContent = fmtDate(e.date);

    row.appendChild(left); row.appendChild(mid); row.appendChild(right);
    row.onclick = ()=>{ state.active = idx; renderList(); openEmail(e); };
    list.appendChild(row);
  });
}

function openEmail(e){
  document.getElementById('vSubject').textContent = e.subject;
  document.getElementById('vFrom').innerHTML = '<b>'+esc(e.from||'')+'</b>';
  document.getElementById('vTo').textContent = parseAddrs(e.to);
  document.getElementById('vDate').textContent = fmtDate(e.date);
  document.getElementById('vMsgId').textContent = e.messageId||'â€”';
  const vL = document.getElementById('vLabels'); vL.innerHTML='';
  e.labels.forEach(l=>{ const c=document.createElement('div'); c.className='chip'; c.textContent=l; vL.appendChild(c); });

  const htmlBox = document.getElementById('htmlBox');
  const textBox = document.getElementById('textBox');
  if(e.content.kind==='html'){
    htmlBox.classList.remove('hidden'); textBox.classList.add('hidden');
    const iframe = document.getElementById('htmlFrame');
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    // Sanitize by isolating in sandboxed iframe; we also strip <script> tags.
    const safe = e.content.value.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi,'');
    doc.open();
    doc.write('<!doctype html><html><head><meta charset="utf-8"></head><body>'+safe+'</body></html>');
    doc.close();
  } else {
    htmlBox.classList.add('hidden'); textBox.classList.remove('hidden');
    textBox.textContent = e.content.value;
  }

  const atts = document.getElementById('vAtts');
  atts.innerHTML='';
  if(e.attachments && e.attachments.length){
    const h = document.createElement('div'); h.className='small'; h.style.margin='0 0 8px 0'; h.textContent='Attachments'; atts.appendChild(h);
    e.attachments.forEach((a,i)=>{
      const row = document.createElement('div'); row.className='att';
      const meta = document.createElement('div'); meta.className='meta'; meta.textContent = (a.filename||('attachment-'+(i+1))) + ' Â· ' + (a.mime||'application/octet-stream');
      const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Download';
      btn.onclick = ()=>{
        let blob;
        try { blob = new Blob([a.raw], {type: a.mime||'application/octet-stream'}); }
        catch(_){ blob = new Blob([new TextEncoder().encode(a.raw)], {type: a.mime||'application/octet-stream'}); }
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a'); link.href=url; link.download=a.filename||'attachment';
        document.body.appendChild(link); link.click(); link.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 5000);
      };
      row.appendChild(meta); row.appendChild(btn); atts.appendChild(row);
    });
  }
}

// --- Loading / parsing ------------------------------------------------------
const fileInput = document.getElementById('file');
const dropzone = document.getElementById('dropzone');
const q = document.getElementById('q');
const statusEl = document.getElementById('status');
const bar = document.getElementById('bar');
const meta = document.getElementById('meta');

function updateStatus(txt){ statusEl.textContent = txt; }

function handleFile(file){
  updateStatus('Reading '+file.name+' â€¦');
  const reader = new FileReader();
  const t0 = performance.now();
  reader.onload = () => {
    const text = reader.result;
    updateStatus('Splitting messagesâ€¦');
    const parts = splitMbox(text, (n)=>{ bar.style.width = Math.min(90, 10 + n%80) + '%'; });
    const total = parts.length; let done=0;
    const emails = [];
    for(const chunk of parts){
      const em = parseEmail(chunk);
      emails.push(em);
      done++;
      if(done % 50 === 0){ bar.style.width = (10 + Math.floor(80*done/total)) + '%'; }
    }
    state.emails = emails;
    // Collect labels
    state.labels = new Map();
    emails.forEach(e=>{ e.labels.forEach(l=> state.labels.set(l, (state.labels.get(l)||0)+1)); });
    state.query=''; state.labelFilter=null; state.mailbox='All Mail'; state.active=-1;
    filterEmails(); renderLabelChips(); renderNav();
    bar.style.width='100%';
    const ms = Math.max(1, Math.round(performance.now()-t0));
    meta.textContent = `${emails.length} messages Â· ${(file.size/1e6).toFixed(2)} MB Â· parsed in ${ms} ms`;
    updateStatus('Loaded');
  };
  reader.onerror = () => updateStatus('Error reading file');
  reader.readAsText(file);
}

fileInput.addEventListener('change', (e)=>{
  const f = e.target.files?.[0]; if(f) handleFile(f);
});

['dragenter','dragover'].forEach(ev=>dropzone.addEventListener(ev,(e)=>{e.preventDefault(); dropzone.style.borderColor='var(--accent)';}));
['dragleave','drop'].forEach(ev=>dropzone.addEventListener(ev,(e)=>{e.preventDefault(); dropzone.style.borderColor='var(--muted)';}));

dropzone.addEventListener('drop', (e)=>{ const f = e.dataTransfer.files?.[0]; if(f) handleFile(f); });

q.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ state.query = q.value.trim(); filterEmails(); }});

// Initial render
renderNav(); renderLabelChips();
</script>
</body>
</html>
